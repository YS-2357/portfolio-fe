---
태그: []
날짜: "2025-12-09"
이름: "25.12.09 (화)"
---

# 25.12.09 (화)


# 📅 날짜: 25.12.09 (화)


## 🧩 주요 업무


- PDF 파서에 개인정보(PII) 마스킹 로직을 추가하여 LLM 연동 시 개인정보 유출 위험을 구조적으로 차단함

- 비동기 PDF 파싱 및 컬럼명 정규화 계층을 도입해 보험사별 상이한 컬럼명을 표준 스키마로 통합하고 후속 분석 코드를 단순화함

- 보장 상세내역 스키마를 확장하고 Streamlit UI에 상세 정보를 노출하여 “보장 총액” 뿐 아니라 상품 단위까지 추적 가능한 분석 화면을 구현함

- FastAPI Swagger UI 문서를 강화해 엔드포인트, 필드 설명, 예시, 에러 응답 구조를 명확히 정의함

- Pydantic Settings 기반 중앙집중 설정 관리 구조를 도입해 모델·포트·보험료 기준 등 환경 설정을 단일 진입점에서 관리하도록 개선함

- 페르소나 그리드(나이·소득·부양가족 조합)를 480개 → 8,712개로 확장하고 생성 CSV는 gitignore 처리하여 운영 구조를 정리함

## 🎯 목표 정리


### 장기 목표


- 보험 PDF·보장내역·프로필 정보를 안전하게 처리하면서도, 다양한 보험사 포맷을 통합 처리할 수 있는 “범용 보험 보장분석 엔진” 구축

- InsureGPT를 인톡파트너스 2.0의 보장분석/챗봇 핵심 백엔드로 활용 가능한 수준으로 고도화하고, 실무자가 신뢰할 수 있는 품질·속도·보안 기준 확보

### 단기 목표


- PII 필터링, 컬럼 정규화, 상세내역 스키마 등의 변경사항을 기반으로 한 엔드투엔드 분석 테스트 완료

- Swagger UI를 통해 팀원·외부 개발자가 바로 연동 가능한 수준의 API 문서 상태 유지

- 설정값 변경 시 코드 수정 없이 `.env`/환경변수만으로 조정 가능한 운영 환경 정착

## ⚙️ 진행 및 이슈


- **PII 필터링 도입**

- **비동기 PDF 파싱 및 컬럼 정규화**

- **보장 상세내역 스키마 및 UI 연동**

- **문서화·설정·구조 정리**

## 🧠 느낀 점 및 개선


- PII 필터링, 컬럼 정규화, 설정 중앙관리가 모두 “나중에 하면 더 힘든 영역”이라는 점을 확인했으며, 앞으로 신규 기능 설계 단계에서 보안·표준화·설정 관리 관점을 함께 고려하는 것이 효율적임을 재확인함

- 컬럼 정규화와 상세내역 노출을 통해, 단순 보장총액 비교에서 “어떤 상품 조합으로 해당 보장이 형성되어 있는지”까지 추적 가능한 수준으로 분석 깊이가 증가했으며, 후속 리포트 설계 시 이 구조를 적극 활용할 필요가 있음

## 🤝 협업 및 커뮤니케이션


- Swagger UI 문서화 및 Settings 구조 도입은 향후 팀원 온보딩과 API 연동 협업에서 공통 레퍼런스로 사용 가능하며, 인톡파트너스 2.0 기획·프론트엔드 측과의 인터페이스 정의에 활용 가능함

- 상세내역 표시 구조를 통해, 기획·영업 측에서 중복 가입·불필요 상품 식별 로직을 논의할 수 있는 구체적인 데이터 포맷을 제공하게 됨

## 📚 참고 및 학습 내용


- Pydantic Settings 및 `@lru_cache()`를 활용한 설정 싱글톤 패턴

- 개인정보 패턴 인식 및 마스킹 규칙 설계 방법

- 컬럼명 정규화 및 LLM Fallback을 결합한 데이터 표준화 전략

- FastAPI Swagger 문서 확장 시 description·example·responses 활용 방식

## 📈 성과 및 지표


- PDF 분석 파이프라인에서 컬럼명 분기 로직 감소(표준 컬럼 사용으로 코드 복잡도 감소)

- 분석 속도: 비동기 파싱 및 이전 최적화까지 포함해 기존 약 3분 수준에서 약 40초 수준으로 단축된 상태 유지

- 판단 기준 피드백 반영 및 보정 후 보험 분석 정확도 90% 이상 수준 유지

## 🗓️ 내일 계획


- 확장된 페르소나 그리드를 활용한 표준 CSV 생성/활용 시나리오 점검 및 일부 샘플 케이스 검증

- PII 필터링 및 컬럼 정규화 적용 후 전체 엔드투엔드 테스트(업로드 → 파싱 → 분석 → UI 반영) 수행

- 인톡파트너스 2.0 보장분석/챗봇 기능을 기준으로 API 인터페이스 초안 정리 및 기획안과의 정합성 검토



```json
당신은 ‘업무일지와 회고 정리 전문가’다.  
아래 사용자의 입력을 바탕으로 하루치 업무일지를 Markdown 형식으로 작성하라.  
입력이 비어 있으면 디폴트 예시 내용을 넣는다.  
결과는 실제 업무 문서에 기록 가능한 수준의 정확성·간결성을 유지하라.

---

입력 형식:
[업무 내용]
1. 코드 개발업무
"""
# InsureGPT 작업 일지 - 2025년 12월 9일

## 오늘의 작업 요약

총 8개의 커밋으로 다음 작업들을 완료함:
1. PDF 파서 개인정보 보호 기능 추가
2. 비동기 PDF 파싱 및 컬럼 정규화
3. 보장 상세내역 스키마 확장
4. Swagger UI 문서화 강화
5. Streamlit UI에 보장 상세내역 표시
6. 코드 정리 (불필요 파일 삭제)
7. 중앙집중식 설정 관리 (Pydantic Settings)

---

## 1. PDF 파서 개인정보 보호 기능 추가

### 파일: `backend/pdf_parser.py`

### 왜 필요했나?
- PDF에서 추출한 데이터를 LLM에 전송할 때 **개인정보(PII)가 포함**될 수 있음
- 주민등록번호, 전화번호, 이름 등이 LLM 서버로 전송되면 **개인정보 유출** 위험
- LLM이 개인정보를 학습에 사용할 수도 있음

### 무엇을 했나?

#### 1-1. PII 패턴 정의
```python
PII_PATTERNS = {
    "주민등록번호": re.compile(r'\d{6}[-\s]?\d{7}'),  # 123456-1234567
    "전화번호": re.compile(r'0\d{1,2}[-\s]?\d{3,4}[-\s]?\d{4}'),  # 010-1234-5678
    "이메일": re.compile(r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'),
    "생년월일_6자리": re.compile(r'(?<!\d)\d{6}(?!\d)'),  # 901231
    "한글이름": re.compile(r'^[가-힣]{2,4}$'),  # 홍길동
}
```

#### 1-2. 마스킹 함수
```python
def mask_pii_in_text(text: str) -> str:
    """
    텍스트 내 개인정보를 마스킹 처리

    예시:
    - "홍길동(901231-1)" → "***(******-*)"
    - "010-1234-5678" → "010-1234-****"
    - "test@email.com" → "***@email.com"
    """
```

#### 1-3. LLM 전송 전 sanitize
```python
def sanitize_row_for_llm(row_dict: dict) -> dict:
    """
    LLM에 전송하기 전에 row에서 개인정보 제거/마스킹

    - 키가 개인정보 관련이면 제외 (이름, 주민번호 등)
    - 값에 PII 패턴이 있으면 마스킹
    """
```

### 결과
- LLM에 전송되는 데이터에서 개인정보가 자동으로 마스킹됨
- 개인정보가 많은 테이블(10% 이상)은 LLM 전송에서 제외

---

## 2. 비동기 PDF 파싱 및 컬럼 정규화

### 파일: `backend/pdf_parser.py`, `backend/analyzer.py`

### 왜 필요했나?
- 보험사마다 PDF의 **컬럼명이 다름**
  - A보험사: "월보험료", B보험사: "보험료(월)", C보험사: "납입보험료"
  - 모두 같은 의미인데 이름이 다름
- 코드에서 매번 여러 이름을 체크하는 건 비효율적

### 무엇을 했나?

#### 2-1. 표준 컬럼명 정의
```python
STANDARD_COLUMNS = [
    "회사명", "상품명", "담보명", "보장명",
    "보험시기", "보험종기", "납입주기", "납입기간",
    "보험료", "가입금액", "담보상태",
    "자기부담비율", "보상비율"
]
```

#### 2-2. 키워드 기반 매핑 (1차)
```python
COLUMN_ALIAS_MAP = {
    "월보험료": "보험료",
    "보험료(월)": "보험료",
    "납입보험료": "보험료",
    "보험가입금액": "가입금액",
    "보장금액": "가입금액",
    # ... 약 30개 매핑
}
```

#### 2-3. LLM Fallback (2차)
키워드 매핑에 없는 컬럼은 LLM에게 물어봄:
```python
async def _normalize_columns_with_llm(unmapped_columns: list[str]) -> dict[str, str]:
    """
    매핑되지 않은 컬럼명을 LLM에게 물어서 표준 컬럼명으로 변환

    예: "보험료(원/월)" → LLM 판단 → "보험료"
    """
```

#### 2-4. 비동기 파싱 함수
```python
async def parse_pdf_async(pdf_source) -> dict:
    """
    PDF 파싱 (비동기 버전)

    1. pdfplumber로 테이블 추출
    2. 모든 컬럼명 수집
    3. 컬럼명 정규화 (키워드 → LLM Fallback)
    4. 정규화된 컬럼명으로 데이터 반환
    """
```

### 결과
- `analyzer.py`에서 더 이상 여러 컬럼명을 체크할 필요 없음
- Before: `row.get("보험료") or row.get("월보험료") or row.get("보험료(월)")`
- After: `row.get("보험료")`  # 이미 정규화됨

---

## 3. 보장 상세내역 스키마 확장

### 파일: `backend/schemas.py`

### 왜 필요했나?
- 기존에는 보장명별로 **합계 금액만** 표시
- 사용자가 "이 보장이 어떤 상품에서 나온 건지" 알 수 없었음
- 상세 내역(회사명, 상품명, 담보명, 보험기간 등)을 보여줘야 함

### 무엇을 했나?

#### 3-1. 보장상세내역 스키마 추가
```python
class 보장상세내역(BaseModel):
    """개별 보장의 상세 정보 (PDF에서 추출)"""
    회사명: str = ""        # 예: "삼성화재"
    상품명: str = ""        # 예: "무배당 건강보험"
    담보명: str = ""        # 예: "암진단보험금"
    보험시기: str = ""      # 예: "2020-01-01"
    보험종기: str = ""      # 예: "2050-01-01"
    납입주기: str = ""      # 예: "월납"
    보험료: int = 0         # 예: 15000 (원)
    가입금액: int = 0       # 예: 10000000 (원)
```

#### 3-2. 정액보장매칭에 상세내역 리스트 추가
```python
class 정액보장매칭(BaseModel):
    보장명: str
    가입금액: int           # 합계 금액
    상세내역: list[보장상세내역] = []  # ← 추가됨!
    # ... 기타 필드
```

### 결과
- 하나의 보장명에 여러 상품이 매핑될 수 있음
- 예: "암진단비" → [{삼성화재, 1000만원}, {한화생명, 2000만원}]

---

## 4. Swagger UI 문서화 강화

### 파일: `backend/app.py`

### 왜 필요했나?
- FastAPI의 `/docs`에서 API 문서를 볼 수 있음
- 하지만 설명이 부족해서 **처음 보는 사람이 이해하기 어려움**
- 주니어 개발자도 보고 바로 사용할 수 있게 상세 설명 필요

### 무엇을 했나?

#### 4-1. Enum 클래스에 설명 추가
```python
class AgeGroup(str, Enum):
    """
    나이대 구분 (10년 단위)

    - 0s: 0~9세 (영유아)
    - 10s: 10~19세 (청소년)
    - 20s: 20~29세 (청년)
    - ...
    """
```

#### 4-2. 스키마 필드에 상세 description
```python
class ChatRequest(BaseModel):
    session_id: str = Field(
        ...,
        description="세션 식별자. 대화 맥락 유지에 사용. UUID v4 권장.",
        example="550e8400-e29b-41d4-a716-446655440000"
    )
    message: str = Field(
        ...,
        min_length=1,
        max_length=2000,
        description="사용자 메시지. 보험 관련 질문 또는 분석 결과 문의.",
        example="암보험 가입금액이 적정한가요?"
    )
```

#### 4-3. 엔드포인트 docstring 보강
```python
@app.post("/chat")
async def chat_endpoint(request: ChatRequest) -> ChatResponse:
    """
    보험 상담 챗봇

    ## 처리 흐름
    1. 메시지 요약 (긴 질문 압축)
    2. 의도 분류 (greeting, analysis, recommendation 등)
    3. 이전 대화 컨텍스트 로드
    4. 답변 생성 (LLM)
    5. 답변 검증 및 보정

    ## 의도 유형
    | 의도 | 설명 | 예시 |
    |-----|------|-----|
    | greeting | 인사 | "안녕하세요" |
    | analysis | 분석 문의 | "내 보험 진단 결과는?" |
    | recommendation | 추천 요청 | "어떤 보험을 더 들어야 할까요?" |
    """
```

#### 4-4. 422 Validation Error 예시 추가
```python
responses={
    422: {
        "description": "유효성 검사 실패",
        "content": {
            "application/json": {
                "example": {
                    "detail": [{
                        "loc": ["body", "message"],
                        "msg": "field required",
                        "type": "value_error.missing"
                    }]
                }
            }
        }
    }
}
```

### 결과
- `/docs` 접속 시 상세한 API 문서 확인 가능
- 각 필드의 의미, 예시, 제약조건을 바로 알 수 있음

---

## 5. Streamlit UI에 보장 상세내역 표시

### 파일: `frontend/streamlit_app.py`

### 왜 필요했나?
- 스키마에 상세내역을 추가했으니 **UI에서도 보여줘야 함**
- 사용자가 "암진단비 3000만원"만 보면 어떤 상품인지 모름
- 상세내역을 펼쳐서 확인할 수 있어야 함

### 무엇을 했나?

#### 5-1. 상세내역 expander 추가
```python
# 개별보장분석 탭에서
if item.get("상세내역"):
    details = item["상세내역"]
    with st.expander(f"📋 상세내역 ({len(details)}개 상품)"):
        for d in details:
            st.markdown(f"""
            - **{d.get('회사명', '-')}** | {d.get('상품명', '-')}
              - 담보: {d.get('담보명', '-')}
              - 기간: {d.get('보험시기', '-')} ~ {d.get('보험종기', '-')}
              - 납입: {d.get('납입주기', '-')} | 보험료: {d.get('보험료', 0):,}원
              - 가입금액: {d.get('가입금액', 0):,}원
            """)
```

### UI 구조
```
보장명 [진단결과] 중요도 (N개 상품)
├── 금액 비교: 가입 3,000만원 / 권장 2,000~5,000만원
├── 📋 상세내역 (3개 상품)    ← 클릭하면 펼쳐짐
│   ├── 삼성화재 | 무배당건강보험
│   │   └── 암진단보험금 | 2020~2050 | 월납 15,000원 | 1,000만원
│   ├── 한화생명 | 무배당종합보험
│   │   └── 암진단비 | 2021~2051 | 월납 20,000원 | 2,000만원
│   └── ...
├── 판단근거: ...
└── AI 코멘트: ...
```

### 결과
- 사용자가 각 보장이 어떤 상품에서 나온 건지 확인 가능
- 중복 가입, 불필요한 상품 식별에 도움

---

## 6. 코드 정리

### 파일: `backend/coverage_classifier.py`, `backend/main.py`

### 무엇을 했나?
- `main.py` 삭제: `app.py`로 통합되어 더 이상 필요 없음
- `coverage_classifier.py`: 사소한 수정

### 왜?
- 불필요한 파일이 있으면 혼란을 줌
- "이 파일은 뭐지?" → 시간 낭비

---

## 7. 중앙집중식 설정 관리 (Pydantic Settings)

### 파일: `utils/config.py` (전면 개편)

### 왜 필요했나?
- 설정값이 여러 파일에 **하드코딩**되어 있었음
  ```python
  # analyzer.py
  model = "gpt-4o-mini"

  # chatbot.py
  model = "gpt-4o-mini"

  # pdf_parser.py
  model = "gpt-4o-mini"
  ```
- 모델을 바꾸려면 **3개 파일을 수정**해야 함
- 환경변수(`.env`)와 코드의 연결이 명확하지 않음

### 무엇을 했나?

#### 7-1. Pydantic Settings 클래스
```python
from pydantic_settings import BaseSettings
from pydantic import Field

class Settings(BaseSettings):
    """
    InsureGPT 설정 클래스
    환경변수 또는 .env 파일에서 값을 로드
    """

    # API Keys
    OPENAI_API_KEY: str = Field(default="", description="OpenAI API Key")

    # LLM 설정
    OPENAI_MODEL: str = Field(default="gpt-4o-mini", description="OpenAI 모델명")
    OPENAI_TEMPERATURE: float = Field(default=0.0, description="LLM Temperature")
    OPENAI_TEMPERATURE_CREATIVE: float = Field(default=0.7, description="창의적 답변용")

    # 서버 설정
    API_HOST: str = Field(default="0.0.0.0", description="FastAPI 호스트")
    API_PORT: int = Field(default=8000, description="FastAPI 포트")
    STREAMLIT_PORT: int = Field(default=8501, description="Streamlit 포트")

    # 보험료 비율 기준
    PREMIUM_RATIO_SINGLE: float = Field(default=5.0, description="미혼 적정 비율 (%)")
    PREMIUM_RATIO_MARRIED: float = Field(default=10.0, description="기혼 적정 비율 (%)")

    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"
```

#### 7-2. 싱글톤 패턴
```python
from functools import lru_cache

@lru_cache()  # 한 번만 생성, 이후 캐시 반환
def get_settings() -> Settings:
    settings = Settings()
    settings.setup_langsmith()
    return settings
```

#### 7-3. 사용 방법 (모든 파일에서)
```python
# Before (하드코딩)
llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)

# After (설정에서 가져오기)
from utils.config import get_settings
settings = get_settings()

llm = ChatOpenAI(
    model=settings.OPENAI_MODEL,
    temperature=settings.OPENAI_TEMPERATURE,
    api_key=settings.OPENAI_API_KEY,
)
```

#### 7-4. 수정된 파일들
- `backend/analyzer.py`
- `backend/chatbot.py`
- `backend/pdf_parser.py`
- `backend/app.py`
- `frontend/streamlit_app.py`
- `main.py`
- `backend/standard_loader.py` (debug_log → logger 변경)

### 추가 작업

#### 7-5. 페르소나 변수 확장
```python
# scripts/generate_standard_csv.py

# Before: 480개 조합
AGE_OPTIONS = ["20s", "30s", "40s", "50s", "60s"]
INCOME_OPTIONS = [300, 500, 700, 1000]
DEPENDENTS_OPTIONS = [0, 1, 2, 3]

# After: 8,712개 조합
AGE_OPTIONS = ["0s", "10s", "20s", "30s", "40s", "50s", "60s", "70s", "80s", "90s", "100s"]
INCOME_OPTIONS = [0, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000]
DEPENDENTS_OPTIONS = [0, 1, 2, 3, 4, 5]
```

#### 7-6. gitignore 추가
```gitignore
# 생성된 CSV 파일 (8,712개)
data/standard_generated/
```

#### 7-7. debug_log() 제거
- `utils/config.py`에서 `debug_log()` 함수 삭제
- `backend/standard_loader.py`에서 `utils/logger.get_logger()` 사용으로 변경

### 결과
- 설정 변경 시 `.env` 파일만 수정하면 됨
- 타입 검증: 잘못된 값 입력 시 시작할 때 에러 발생
- 기본값 제공: `.env`가 없어도 기본값으로 동작

---

## 오늘의 커밋 목록

| 시간 | 커밋 | 내용 |
|------|------|------|
| 14:16 | `30ada48` | PDF 파서 PII 필터링 |
| 14:16 | `8c6edeb` | 비동기 PDF 파싱 적용 |
| 14:17 | `b511522` | 보장상세내역 스키마 |
| 14:17 | `abb9aac` | Swagger UI 문서화 |
| 14:18 | `24c5eab` | Streamlit 상세내역 UI |
| 14:18 | `754ba5b` | 코드 정리 |
| 14:20 | `8d28df3` | 422 에러 예시 추가 |
| 15:05 | `7374875` | Pydantic Settings 설정 관리 |
---

## 배운 점 / 참고 사항

### 1. Pydantic Settings 패턴
- 환경변수 관리의 표준 방법
- 타입 검증 + 기본값 + 설명을 한 곳에서 관리
- `@lru_cache()`로 싱글톤 구현

### 2. PII 처리의 중요성
- LLM에 개인정보를 보내면 안 됨
- 정규표현식으로 패턴 감지 → 마스킹 또는 제외

### 3. 컬럼명 정규화
- 데이터 표준화의 중요성
- 키워드 매핑 → LLM Fallback 2단계 전략

### 4. 문서화
- Swagger UI는 FastAPI의 강력한 기능
- Field의 description, example을 잘 활용하면 별도 문서 불필요

"""
2. (회의, 개발, 보고 등)

[느낀 점]
1. (업무 중 느낀 점, 개선점, 배운 점 등)

---

출력 양식:

# 📅 날짜: (예: 25.11.11 (화))

## 🧩 주요 업무
- 오늘 수행한 핵심 업무를 구체적으로 요약  
- 기술적 결과, 진행 상황, 산출물 등을 명시  

## 🎯 목표 정리
### 장기 목표
- 프로젝트의 중장기적 방향 또는 최종 지향점  
### 단기 목표
- 오늘 혹은 이번 주 달성 목표  

## ⚙️ 진행 및 이슈
- 진행 단계별 구체적 내용  
- 발생한 문제와 해결 과정  
- 미해결 과제 및 후속 조치  

## 🧠 느낀 점 및 개선
- 사용자 입력 기반으로 정리된 통찰, 개선 아이디어, 학습 내용  

## 🤝 협업 및 커뮤니케이션
- 회의, 보고, 협업 이슈, 의사소통 내용 정리  
- 논의된 결정사항 및 향후 조율 방향  

## 📚 참고 및 학습 내용
- 새로 학습하거나 참고한 기술·논문·문서  
- 업무 개선에 도움이 된 개념 또는 자료  

## 📈 성과 및 지표
- 정량적 성과(예: 정확도, 속도, 효율 등)  
- 수치가 없을 경우 주요 진척도를 서술  

## 🗓️ 내일 계획
- 다음 업무 목표 및 우선순위  
- 예상 리스크 및 대비책  

---

지침:
1. 전체 분량은 500~650단어 이내로 유지한다.  
2. 문장은 명사형·서술형으로 끝내며, 감정적 표현은 제외한다.  
3. 입력이 비어 있으면 아래 기본 내용을 자동으로 채운다.
4. 날짜는 월화수목금의 요일만 사용한다.

---

[기본 디폴트 예시]
- **업무 내용**: LangChain 실습 복습, 문서 분석 코드 개선, 팀 회의 참석  
- **느낀 점**: 구조화된 학습이 업무 이해에 도움됨. 반복 작업 효율 개선 필요.
```

